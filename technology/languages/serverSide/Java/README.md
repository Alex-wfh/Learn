# Java

使用Java有段时间了，当初工作需要开始接触，摸着石头过河，绝大部分对Java的理解源自平时搬砖，说实话目前我所看到的Java并不符合我的审美，甚至某些Java项目（工作中涉及业务的Java项目，我不觉得自己有资格评价Java及被广泛使用的Java开源项目）的架构与我的技术观出入极大。即日起，我准备系统性地学习Java，很期待对Java理解渐渐深入的我回头看今日我的肤浅及粗糙。
2019/6/12



## Java语言概述与开发环境

### Java 程序运行机制

#### 编译型语言 vs 解释型语言

Java 是一种特殊的高级语言，Java 程序要经过先编译，后解释两个步骤，所以 Java 同时具有编译型语言和解释型语言的特性。

* 编译型语言（一次性”翻译“）
  * 使用专门的编译器，针对特定平台（操作系统）将某种高级语言代码一次性“翻译”成可被该平台硬件执行的机器码（包括机器指令和操作数），并包装成该平台所能识别的可执行性程序的格式，这个转换过程称为编译（Compile）。编译生成的可执行性程序可以脱离开发环境，在特定平台上独立运行。
  * 机器码可脱离开发环境独立运行，运行效率较高，无法移植到其他平台使用。
  * 典型编译型语言：C、C++、Object-C、Swift、Kotlin。
* 解释型语言（逐行”翻译“）
  * 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行的语言。解释型语言通常不会进行整体性的编译和链接处理，解释型语言相当于把编译型语言中的编译和解释过程混合到一起同时完成。
  * 可以认为：每次执行解释型语言的程序都需要进行一次编译，因此解释型语言的程序运行效率通常较低，而且不能脱离解释器独立运行。但跨平台比较容易，只需特定平台的解释器即可。
  * 典型解释型语言：JavaScript、Python、Ruby。
* 伪编译型语言（半编译型语言）
  * 首先编译成特定的半机器码（介于语言和机器码中间的代码），并将解释引擎封装在可执行性程序内，当运行程序时，半机器码会被解析成真正的机器码。
  * 伪编译型语言看起来可以脱离开发环境，在特定平台上运行，实际上跟编译型语言还是有很大差别的。
  * 典型的伪编译语言：Visual Basic，他的半机器码：P-代码。

#### Java 程序的运行机制和 JVM

Java 语言比较特殊，由 Java 语言编写的程序需要经过编译步骤，但这个编译步骤并不会生成特定平台的机器码，而是生成一种与平台无关的字节码（也就是 *.class 文件）。当然，这种字节码不是可执行的，必须使用 Java 解释器来解释执行

```mermaid
graph TB
	J("Java源文件(程序员编写的 *.java 文件)")--使用javac编译-->c("字节码文件(编译生成的 *.class 文件)")
	c--使用java解释执行-->m("特定的平台机器码")
```

Java 语言里负责执行字节码文件的是 Java 虚拟机，即 JVM（Java Virtual Machine）。JVM 是可运行 Java 字节码文件的虚拟计算机。所有平台上的 JVM 向编译器提供相同的编程接口，而编译器只需要面向虚拟机，生成虚拟机能理解的代码，然后由虚拟机来解释执行。在一些虚拟机的实现中，还会将虚拟机代码转换成特定系统的机器码执行，从而提高执行效率。

当使用 Java 编译器编译 Java 程序时，生成的是与平台无关的字节码，这些字节码不面向任何具体的平台，只面向 JVM。不同平台的 JVM 都是不同的，但他们提供了相同的接口。JVM 是 Java 程序跨平台的关键部分，只要为不同平台实现了相应的虚拟机，编译后的 Java 字节码就可以在该平台上运行。显然，相同的字节码程序需要在不同的平台上运行，这几乎是”不可能的“，只有通过中间的转换器才可以实现，JVM 就是这个转换器。

JVM 是一个抽象的计算机，和实际的计算机一样，它具有指令集并使用不同的存储区域。它负责执行指令，还要管理数据、内存和寄存器。

Oracle 公司制定的 Java 虚拟机规范在技术上规定了 JVM 的统一标准，具体定义了 JVM 的如下细节：

* 指令集
* 寄存器
* 类文件的格式
* 栈
* 垃圾回收堆
* 存储区

### Java 准备

安装并配置 JDK

#### JDK vs JRE

* JDK（Java SE Development Kit），即 Java 标准版开发包，提供了编译、运行 Java 所需要的各种工具和资源，包括 Java 编译器、Java 运行环境、及常用的 Java 类库等。
* JRE（Java Running Envirenment），即 Java 运行环境，包括 JVM（运行 Java 程序的核心虚拟机）、类加载器、字节码校验器以及大量的基础类库。

#### Java SE vs Java EE vs Java Me

* Java SE（Java Platform，Standard Edition）标准版本，桌面应用开发。
  Java EE（Java Platform，Enterprise Edition）企业版本，Web 程序开发。
  Java ME（Java Platform，Micro Edition）微型版本，手机应用开发。

#### 安装目录结构

* bin：JDK 的各种工具命令，例如 javac、java，一般安装成功后在PATH中加入该路径
* conf：JDK 的相关配置文件
* include：平台特定的头文件
* jmods：JDK 的各种模块
* legal：JDK 各种模块的授权文档
* lib：JDK 工具的一些补充 JAR 包
* README 和 COPYRIGHT 文档说明

###第一个 Java 程序

1. 编辑 Java 源代码

2. 编译 Java 程序

   ```shell
   javac -d destdir srcFile
   # -d destdir 是javac命令的选项，用以指定编译生成的字节码文件存放的路径
   # srcFile 是 Java 源文件所在的位置
   # 例如：
   javac -d HelloWorld.java
   ```

3. 运行 Java 程序

   ```shell
   java Java类名
   # 例如：
   java HelloWorld
   ```

### Java 程序的基本规则

#### 组织形式

Java 程序是一种纯粹的面向对象的程序设计语言，必须以类（Class）的形式存在，类是 Java 程序的最小程序单位。Java 程序不允许可执行性语句、方法等成分独立存在，所有的程序部分必须放在类里。

```java
public class HelloWorld{
	public static void main(String[] args){
    System.out.println("Hello World!");
  }
}
```

一个 Java 程序往往只需要一个入口，也就只有一个类包含 main 方法，而其他类都是被 main 方法直接或间接调用的。

#### 命名规则

* Java 文件的扩展名必须是 .java。
* 如果 Java 程序源代码里定义了一个 public 类，则该源文件的主文件名必须与该 public 类的类名相同，如果没定义 public 类，则主文件名可以任意，但推荐与类名相同。
* 一个 Java 源文件只能定义一个类，不同的类使用不同的源文件定义。

### 垃圾回收机制

Java 程序的内存分配和回收都是由 JRE 在后台自动进行的（隐式的），所有的 JVM 实现都有一个由垃圾回收器管理的堆内存，这种实现方式有以下优点：

* 提高编程效率
* 保护程序的完整性

垃圾回收特点：

* 垃圾回收器只回收内存资源，对其他物力资源，如数据库连接、磁盘I/O等资源则无能为力。
* 为了让垃圾回收器更快回收那些不再被使用的对象，可以将对象的引用变量设置为 null。
* 垃圾回收发生不可预知，不同 JVM 采用不同的垃圾回收机制和垃圾回收算法，可以调用对象的 gc() 或  System.gc() 等方法建议系统进行垃圾回收，但仅仅是建议，依旧不能精准控制垃圾回收机制的执行。
* 垃圾回收的精确性主要包括两个方面：
  * 能够精确地标记活着的对象
  * 能够精确地定位对象之间的引用关系
* 现在的 JVM 有多种不同的垃圾回收实现



## 理解面向对象

### 面向对象

目前软件开发领域有两种主流的开发方法：结构化开发方法和面向对象开发方法。

#### 结构化程序设计

结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自订向下、逐步求精、模块化等，也称面向功能的程序设计、面向数据流的处理方式。

结构化程序设计里最小的程序单元是函数，程序入口为主函数，主函数调用普通函数、普通函数间相互调用，完成整个软件系统的功能。

#### 程序的三种基本结构

* 顺序
* 选择
* 循环
  * 当型循环
  * 直到型循环

#### 面向对象程序设计

面向对象的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。强调以现实世界中的的事物（即对象）为中心思考，并根据这些事物的本质特点，把它们抽象地表示为系统中的类。

成员变量（状态数据）+ 方法（行为）= 类定义

#### 面向对象的基本特征

面向对象三个基本特征：

* 封装（Encapsulation）
  * 将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能。
* 继承（Inheritance）
  * 子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法。
* 多态（Polymorphism）
  * 子类对象可以直接赋给父类变量，但运行时依然表现出字类的行为特征，这意味着同一个类型的对象在执行统一方法时，可能表现出多种行为特征。
* 抽象（面向对象的重要部分，非特征，因为所有语言都需要抽象）
  * 忽略一个主题中与当前目标无关的那些方面。

面向对象还支持如下几个功能：

* 对象是面向对象方法中最基本的概念，他的基本特点有：标识唯一性、分类性、多态性、封装性、模块独立性等。
* 类是具有共同属性、共同方法的一类事物。类是对象的抽象；对象则是类的实例。
* 对象间相互合作需要一个机制协助进行，这个机制称为“消息”。消息是一个实例与另一个实例之间相互通信的机制。
* 面向对象方法中国呢，类之间共享属性和操作的机制称为继承。继承具有传递性，继承可分为单继承和多继承，由于多继承可能引起继承结构混乱，降低程序的可理解性，所以 Java 不支持多继承。

判断一门语言是否是面向对象的，通常可以用继承和多态特性。

### UML（统一建模语言）

面向对象的方式由 OOA（面向对象分析）、OOD（面向对象设计）、OOP（面向对象编程）三部分有机组成，OOA 和 OOD 的结构需要一种方式来描述并记录，目前业界统一采用 UML（统一建模语言）。

UML 是一种定义良好、易于表达、功能强大且普遍适用的建模语言，它的作用域不限于支持面向对象的分析与设计，还支持从需求分析开始的软件开发全过程。

```mermaid
graph LR
	U("UML2.0")-->S("静态图")
	U-->D("动态图")
	S-->用例图
	S-->类图
	S-->包图
	S-->组件图
	S-->对象图
	S-->部署图
	S-->复合结构图,2.0新增
	D-->顺序图
	D-->通信图
	D-->状态机图
	D-->活动图
	D-->定时图,2.0新增
	D-->交互概观图,2.0新增
```

### Java 的面向对象特征

Java 是纯粹的面向对象编程语言

#### 一切都是对象

在 Java 语言中，除8个基本数据类型值之外，一切都是对象。对象不仅能表示具体的事物，也能表示抽象的规则、计划或事件。

* 对象具有状态，Java 通过定义成员变量来描述对象的状态。
* 对象还有操作，这些操作可以改变对象的状态，操作也被称为行为，Java 通过定义方法来描述对象的行为。
* 对象实现了数据和操作的结合。
* 对象是 Java 程序的核心，所以 Java 里的对象具有唯一性，每个对象都有一个标识来引用它，某个对象失去了标识，这个对象将变成垃圾，只能等垃圾回收机制来回收它。
* Java 语言不允许直接访问对象，而是通过对对象的引用来操作对象。

#### 类和对象

具有相同或相似性质的一组对象的抽象就是类，类是对一类事物的描述，是抽象的、概念上的定义；对象是实际存在的该类事物的个体，因而也称为实例（instance）。

对象的抽象化是类，类的具象化是对象。

Java 语言使用 class 关键字定义类，定义类时可使用成员变量来描述该类对象的数据，可使用方法来描述该类对象的行为特征。

* 一般 → 特殊关系：典型继承关系。
* 整体 → 部分结构关系：组装结构，典型组合关系。



## 数据类型和运算符

Java 提供了丰富的基本数据类型

* 数值类型
  * 整型
  * 字符型
  * 浮点型
  * 所有数值类型之间可以进行类型转换
* 布尔类型

Java 提供了功能丰富的运算符

* 算数运算符
* 位运算符
* 比较运算符
* 逻辑运算符
* 运算符和操作数连接在一起就形成了表达式

### 注释

#### 添加注释的必要性

* 永远不要相信自己的理解力！
* 可读性第一，效率第二！
* 代码即文档！

#### 单行注释

在程序中注释一行代码，将 “//” 放在需要注释的内容前。

#### 多行注释

一次性地将多行代码注释掉，使用 “/\*” 和 “\*/“ 将程序中需要注释的内容包含起来。

#### 文档注释

如果编写 Java 源代码时添加了合适的文档注释，然后通过 JDK 提供的 javadoc 工具可以直接将源代码里的文旦注释提取成一份系统的 API 文档。

文档注释以 “/\*\*” 开，以 “\*/“ 结束，中间部分全部是文档注释，会被提取到 API 文档中。

常见的 javadoc 标记：

* @author：指定 Java 程序的作者
* @version：指定源文件的版本
* @deprecated：不推荐使用的方法
* @param：方法的参数说明
* @return：方法的返回参数说明
* @see：“参见”，用于指定交叉参考的被容
* @exception：抛出异常的类型
* @throws：抛出的异常，和 @exception 同义

### 标识符和关键字

#### 分隔符

Java 语言里的分号、花括号、方括号、圆括号、空格、句号 都具有特殊的分隔作用，统称为分隔符。

#### 标识符规则

* 可以由字母、数字、下划线和美元符组成，其中数字不能打头。
* 不能是 Java 关键字和保留字
* 不能包含空格
* 不能是单独的数字或下划线或美元符

#### Java 关键字

Java 一共包含50个关键字

| abstract | continue | for        | new       | switch       |
| -------- | -------- | ---------- | --------- | ------------ |
| assert   | default  | if         | package   | synchronized |
| boolean  | do       | goto       | private   | this         |
| break    | double   | implements | protected | throw        |
| byte     | else     | import     | public    | throws       |
| case     | enum     | instanceof | return    | transient    |
| catch    | extends  | int        | short     | try          |
| char     | final    | interface  | static    | void         |
| class    | finally  | long       | strictfp  | volatile     |
| const    | float    | native     | super     | while        |

### 数据类型分类

#### Java 是一门强类型（strongly typed）语言

- 所有变量必须先声明、后使用。
- 指定类型的变量只能接受类型与之匹配的值。

#### 声明变量

```java
type varName[= 初始值];
```

#### 数据类型分类

* 基本类型（Primitive Type）
  * 数字类型
  * 布尔类型
* 引用类型（Reference Type）
  * 类
  * 接口
  * 数组
  * null

空引用（null）只能被转换成引用类型，不能被转换成基本类型，因此不要把 null 赋给基本数据类型的变量。

### 基本数据类型

#### 整数类型

* byte
  * 1个字节（内存里占8位）
  * -2<sup>7 </sup> ~ 2<sup>7</sup>-1
* short
  * 2个字节
  * -2<sup>15</sup>  ~ 2<sup>15</sup>-1
* int
  * 4个字节
  * -2<sup>31</sup>  ~ 2<sup>31</sup>-1
* long：8个字节
  * -2<sup>63</sup>  ~ 2<sup>63</sup>-1
* 如果直接将一个较小的整数（在 byte 或 short 范围内）赋给一个 byte 或 short 变量，系统会自动把这个整数值当成 byte 或 short 类型来处理。
* 如果使用一个巨大的整数（超出了 int 范围）时，Java 不会自动把这个整数值当成 long 类型来处理。如果希望系统把一个整数型当成 long 类型来处理，应该在这个整数值后增加 l 或者 L 作为后缀，推荐使用 L，避免混淆。
* Java 中整数值有4种表示形式：十进制、二进制、八进制、十六进制。二进制以 0b 或 0B 开头；八进制以 0 开头；十六进制以 0x 或 0X 开头。

#### 字符类型

* char
  * 2个字节
  * 必须使用单引号括起来。
  * 字符型值有三种表达形式：
    * 单个字符
    * 转义字符
    * Unicode 值
* Java 没有提供表示字符串的基本数据类型，而是通过 String 类来表示字符串，由于字符串由多个字符组成，因此字符串要使用双引号括起来。

#### 浮点类型

* float：
  * 4个字节
  * 第1位是符号位，接下来8位表示指数，再接下来23位表示尾数。
* double
  * 8个字节
  * 第1位是符号位，接下来11位表示指数，再接下来52位表示尾数。
* 因为 Java 浮点数使用二进制数据的科学计算法表示浮点数，因此可能不能精确表示一个浮点数，使用 double 比 float 更准确，如要求精准，可以考虑 BigDecimal 类。
* Java 语言的浮点数有两种表达形式：
  * 十进制数形式
  * 科学计数法形式，例如：5.12e2（即 5.12*10<sup>2</sup>）
* 浮点数默认是 double 类型，如希望 float 类型，可在该浮点数后紧跟 f 或 F。
* Java 还提供三个特殊的浮点数：正无穷大（POSITIVE_INFINITY）、符无穷大（NEGATIVE_INFINITY）、非数（NaN）。

#### 布尔类型

* boolean
  * true
  * false

### 基本类型的类型转换

Java 语言所提供的7种数值类型之间可以相互转换，有两种转换方式：自动类型转换和强制类型转换。

#### 自动类型转换

* 系统支持把某种基本类型的值直接赋给另一种基本类型的变量，这种方式被称为自动类型转换。
* 当把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，系统将可以进行自动类型转换；否则需要强制类型转换。

```mermaid
graph LR
	char-->int
	byte-->short
	short-->int
	int-->long
	long-->float
	float-->double
```

* 注意：是数的范围，并非占的空间。
* 当任何基本类型的值和字符串值进行连接运算时，基本类型的值将自动类型转换为字符串类型。

#### 强制类型转换

* 强制类型转换的语法格式：(targetType)value 。
* 当试图强制把表数范围大的类型转换为表数范围小的类型时，必须格外小心信息丢失。
* Java 为8种基本类型都提供了对应的包装类：boolean 对应 Boolean、byte 对应 Byte、short 对应 Short、int 对应 Integer、long 对应 Long、char 对应 Character、float 对应 Float、double 对应 Double。8个类都提供了一个 parseXxx(String str) 静态方法用于将字符串转换成基本类型。

#### 表达式类型的自动提升

* 所有的 byte 类型、short 类型和 char 类型将被提升到 int 类型。
* 整个算数表达式的数据类型自动提升到表达式中最高等级操作数相同的类型。

### 直接量

#### 直接量的类型

* 能指定直接量的通常只有三种类型：基本类型、字符串、null 类型。

#### 直接量的赋值

* 把一个直接量赋值给对应类型的变量是合法的。
* 在系统支持自动类型转换的前提下，允许把一个数值直接量直接赋值给另一种类型的变量。
* null 类型的直接量可以直接赋值给任何引用类型的变量。

### 运算符

#### 算数运算符

\+  -  *  /  %  ++  --

#### 位运算符

* &：按位与
* |：按位或
* ~：按位非
* ^：按位异或
* <<：左移
* \>\> ：右移
* \>\>\>：无符号右移

#### 扩展后的赋值运算符

+=  -=  *=  /= %=  &=  |=  ^=  <<=  >>=  >>>=

#### 比较运算符

\>  >=  <  <=  ==  !=

#### 逻辑运算符

* &&：与
* &：不短路与
* ||：或
* |：不短路或
* !：非
* ^：异或

#### 三目运算符

三目运算符的语法格式如下：

```java
(expression) ? if-true-statement : if-false-statement
```

#### 运算符的结合性和优先级

* 单目运算符、赋值运算符、三目运算符是从右向左结合的（从右向左运算），其他的都是从左向右结合的。
* 运算符优先级（上面优先）：

| 运算符说明         | Java 运算符                                    |
| ------------------ | ---------------------------------------------- |
| 分隔符             | .  ()  []  {}  ,  ;                            |
| 单目运算符         | ++  —  ~  !                                    |
| 强制类型转换运算符 | (type)                                         |
| 乘法/除法/求余     | *  /  %                                        |
| 加法/减法          | +  -                                           |
| 移位运算符         | <<  >>  >>>                                    |
| 关系运算符         | <  <=  >  >=  instanceof                       |
| 等价运算符         | ==  !=                                         |
| 按位与             | &                                              |
| 按位异或           | ^                                              |
| 按位或             | \|                                             |
| 条件与             | &&                                             |
| 条件或             | \|\|                                           |
| 三目运算符         | ?:                                             |
| 赋值               | =  +=  -=  *=  /=  &=  \|=  ^=  <<=  >>=  >>>= |

* 不要把一个表达式写得过于复杂，过于复杂就该分成几步来完成。
* 不要过多依赖运算符的优先级来控制执行顺序，可读性太差，尽量用 () 来控制。



## 流程控制与数组

### 顺序结构

从上到下依次执行。

### 分支结构

#### if 条件语句

```java
if (logic expression) {
	statement;
}

if (logic expression) {
	statement;
} else {
  statement;
}

if (logic expression) {
	statement;
} else if (logic expression) {
  statement;
}
```

* 如果执行体只有一行，可省略执行体的花括号，但不建议这样做。
* 使用 if…else 语句时，应先处理范围更小的情况。

#### switch 分支语句

```java
switch (expression){
	case condition1:
	{
		statement;
		break;
	}
	case condition2:
	{
		statement;
		break;
	}
	...
	case conditionN:
	{
		statement;
		break;
	}
	default:
	{
		statement;
	}
}
```

* switch 语句后面的控制表达式的数据类型只能是 byte、short、char、int 四种整数类型，String 和枚举类型。

### 循环结构

循环语句可能包含如下4个部分：

* 初始化语句（init_statement）
* 循环条件（test_expression）
* 循环体（body_statement）
* 迭代语句（interation_statement）

#### while 循环语句

```java
[init_statement]
while (test_expression) {
	statement;
	[iteration_statement]
}
```

#### do while 循环语句

```java
[init_statement]
do{
	statement;
	[interation_statement]
}while (test_expression)
```

#### for 循环语句

```java
for ([init_statement]; [test_expression]; [iteration_statement]) {
	statement;
}
```

#### 控制循环结构

* break ：结束循环。
* continue ：忽略本次循环剩下的语句。
* return ：结束方法。

### 数组类型

#### 理解数组

* Java 中，一个数组里只能存储同一种数据类型的数据。
* 一旦数组初始化完成，它在内存中所占的空间将被固定下来，因此数组的长度将不可改变。
* Java 数组即可存储基本类型的数据，也可以存储引用类型的数据。

#### 定义数组

```java
type[] arrayName;
type arrayName[];
```

* 推荐使用第一种定义方式。
* 定义数组时不能指定数组的长度。
* 定义数组只是定义了个引用变量，并未指向任何有效的内存空间，所以还不能使用，只有对数组进行初始化之后才能使用。

#### 初始化数组

* 静态初始化

  * 初始化时由程序员显示指定数组每个元素的初始值，由系统决定数组长度。

    ```java
    arrayName = new type[]{element1, element2...};
    ```

  * 在定义数组的同时执行初始化操作可简化成以下格式：

    ```java
    type[] arrayName = {element1, element2...};
    ```

* 动态初始化

  * 初始化时程序员只指定数组长度，由系统为数组元素分配初始值。

    ```java
    arrayName = new type[length];
    ```

  * 定义同时初始化：

    ```java
    type[] arrayName = new type[length];
    ```

    

  * 系统默认初始值

    * 整数类型（byte、short、int、long）：0
    * 浮点类型（float、double）：0.0
    * 字符类型（char）：'\u0000'
    * 布尔类型（boolean）：false
    * 引用类型（类、接口、数组等）：null

#### 使用数组

```java
objArr[idx];
```

#### foreach 循环

```
for (type variableName : array | collection) {
	variableName statement;
}
```

### 深入数组

数组是一种引用数据类型，数据引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。

#### 栈(stack)内存 vs 堆(heap)内存

* 实际的数组对象被存储在堆内存中，如果引用该数组对象的引用变量是一个局部变量，那么它被存储在栈内存中。
* 所有在方法中定义的局部变量都放在栈内存中，方法结束栈内存自然销毁。
* 在程序中创建对象时，对象被保存到栈内存，以便重复利用（因为对象创建成本较大），堆内存中的对象不会随方法结束而销毁，只有当没有任何引用变量引用该对象时，系统的垃圾回收器才会在合适的时候回收它。
* 为了让垃圾回收机制回收一个数组所占的内存空间，可以将该数组变量赋值为 null，也就切断了引用变量和实际数组间的引用关系，数组也就成了垃圾。

#### Java8 增强的工具类 Arrays

Arrays 类处于 java.util 包下，使用时必须导入 Java.util.Arrays 类。

Arrays 类包含如下几个 static 方法（static 修饰的方法可以直接通过类名调用）

* int binarySearch(type[] a, type key):
* int binarySearch(type[] a, int fromIndex, int toIndex, type key):
* type[] copyOf(type[] original, int length):
* type[] copyOfRange(type[] original, int from, int to):
* boolean equals(type[] a, type[] a2):
* void fill(type[], type val):
* void fill(type[] a, int fromIndex, int toIndex, type val):
* void sort(type[] a):
* void sort(type[] a, int fromIndex, int toIndex)
* String toString(type[] a):

Java8 为 Arrays 类增加的工具方法如下：

* void parallelPrefix(xxx[] a, XxxBinaryOperator op):
* void parallelPrefix(xxx[] a, int fromIndex, int toIndex, XxxBinaryOperator op):
* void setAll(xxx[] a, IntToXxxFunction generator):
* void parallelSetAll(xxx[] a, IntToXxxFunction generator):
* void parallelSort(xxx[] a):
* void parallelSort(xxx[] a, int fromIndex, int toIndex):
* Spliterator.OfXxx spliterator(xxx[] a):
* Spliterator.OfXxx spliterator(xxx[] a, int startInclusive, int endExclusive):
* XxxStream stream(xxx[] a):
* XxxStream stream(xxx[] a, int startInclusive, int endExclusive):



## 面向对象（上）

Java 是面向对象的程序设计语言，提供了定义类、成员变量、方法等最基本的功能。类可被认为是一种自定义的数据类型，可以使用类来定义变量，所有类定义的变量都是引用变量，它们将会引用到类的对象。Java 程序使用类的构造器来创建该类的对象。

Java 支持面向对象的三大特性：封装、继承、多态。

* Java 提供来 private、protected、public 三个访问控制修饰符来实现良好的封装。
* 提供了 extends 关键字来让子类继承父类，子类可以继承到父类的成员变量和方法。
* 使用继承关系来实现复用时，子类对象可以直接赋值给父类变量，这个变量具有多态性。

构造器用于对类实例进行初始化操作，构造器支持重载，如果多个重载的构造器包含了相同的初始化diamanté，则可以把这些初始化代码放置在普通初始化块里完成，初始化块总在构造器执行之前被调用。Java 还提供了一种静态初始化块，用于初始化类，在类初始化阶段被执行。如果继承树里的某一个类需要被初始化，系统将会同时初始化该类的所有父类。

### 类和对象

#### 定义类

##### Java 语言里定义类的简单语法如下：

```java
[修饰符] class 类名
{
	零到多个构造器定义...
	零到多个成员变量...
	零到多个方法...
}
```

对定义类的语法格式的详细说明如下：

* 修饰符可以是 public、final、abstract，或者完全省略这三个修饰符。
* 类名是合法标识符即可，但一般是由一个或多个有意义的单词连缀而成的，单词首字母大写，其余字母小写。
* 类里各成员之间的定义顺序没有任何影响，各成员之间可以相互调用，但 static 修饰的成员不能访问没有 static 修饰的成员。
* 成员变量用于定义该类或该类的实例所包含的状态数据。
* 方法则用于定义该类或该类的实例的行为特征或功能实现。
* 构造器用于构建该类的实例，Java 语言通过 new 关键字来调用构造器，从而返回该类的实例。
* 构造器是一个类创建对象的根本途径，Java 语言提供一个功能：如果程序员没有为一个类编写构造器，系统会为该类提供一个默认的构造器。

##### 定义成员变量的语法如下：

```java
[修饰符] 类型 成员变量名 [= 默认值];
```

对定义成员变量的语法格式的详细说明如下：

* 修饰符：修饰符可以省略，也可以是 public、protected、private、static、final，其中 public、protected、private 三个最多只能出现其中之一，可以与 static、final 组合起来修饰成员变量。
* 类型：可以是任何类型，包括基本类型和引用类型。
* 成员变量名：合法标识符即可，一般是驼峰式的单词（组合）
* 默认值：定义成员变量可指定一个可选的默认值。
* 成员变量由 field 意译而来，早期有些书籍称之为属性，但实际上在 Java 世界里属性（由 property 意译）是指一组 setter 和 getter 方法。

##### 定义方法的语句格式如下：

```java
[修饰符] 方法返回值类型 方法名[形参列表]
{
	// 零到多条可执行性语句组成的方法体
}
```

对定义方法的语法格式的详细说明如下：

* 修饰符：可省略，也可以是 public、protected、privite、static、final、abstrict，其中 public、protected、privite 最多出现一个；final、abstrict 最多出现一个；可以与 static 组合起来修饰方法。
* 方法返回值类型：任何类型，如果声明了返回值类型，则方法体内必需有一个有效的 return 语句，返回的类型必须与此处声明的类型匹配。如果没有返回值，则必须使用 void 来声明没有返回值。
* 方法名：与成员变量命名规则相同。
* 行参列表：用于定义该方法可接受的参数，由零到多组”参数类型 参数名“组成，多组参数间用英文逗号隔开，一旦定义方法时指定了行参列表，则调用该方法时必须传入对性的参数值。
* static 可用于修饰方法、成员变量等成员，表明所修饰的成员属于这个类本身，而不属于该类的单个实例，通常称为类变量、类方法，也称为静态变量、静态方法。

##### 构造器是一个特殊的方法，定义语法格式如下：

```java
[修饰符] 构造器名(行参列表)
{
	// 零到多条可执行性语句组成的构造器执行体
}
```

对定义构造器的语法格式的详细说明如下：

* 修饰符：可省略，也可是 public、protected、private 之一。
* 构造器名：必须和类名相同。
* 行参列表：与定义方法的行参列表格式相同。

##### Java 中类的大致作用

* 定义变量
* 创建对象
* 调用类方法或者访问类变量

#### 对象的产生和作用

创建对象的根本途径是构造器，通过 new 关键字来调用某个类的构造器即可创建这个类的实例。

```java
// 定义 Person 类型的变量
Person p;
// 通过 new 调用 Person 类的构造器，返回一个 Person 实例，赋给 p
p = new Person();

// 简写
Person p = new Person();
```

##### Java 中对象的大致作用

* 访问对象的实例变量
* 调用对象的方法

static 修饰的方法和成员变量，既可通过类来调用，也可通过实例来调用；没使用 static 修饰的普通方法和成员变量，只能通过实例来调用。

#### 对象、引用和指针

与数组相似，类也是一种引用数据类型。因此程序中定义的 Person 类型的变量实际上是一个引用，它被存放在栈内存里，指向实际的 Person 队形，真正的 Person 对象则存放在堆内存中。

当程序访问引用变量的成员变量或方法时，实际上是访问该引用变量所引用的数组、对象的成员变量或方法。

#### 对象的 this 引用

Java 提供了一个 this 关键字，this 关键字总是指向调用该方法的对象。根据 this 出现位置的不同，this 作为对象的默认引用有两种情形

* 构造器中引用构造器正在初始化的对象。
* 在方法中引用调用该方法的对象。

this 关键字的最大作用就是让类中的一个方法访问该类里的另一个方法或实例变量。

当 this 出现在某个方法体中时，它所代表的对象是不确定的，但他的类型是确定的，只能代表当前类的实例。谁调用这个方法，this 就代表谁。

大部分时候，一个方法访问该类中定义的其他方法、成员变量时加不加 this 前缀效果是完全一致的。

对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用的关键字，则这个关键字就无法指向合适的对象。所以 static 修饰的方法中不能使用 this 引用，所以 static 修饰的方法不能访问不使用 static 修饰的普通成员，因此 Java 语法规定：静态成员不能直接访问非静态成员。

Java 语法允许对象调用 static 修饰的成员变量、方法，但实际编程时应尽量避免。

如果某个方法把 this 作为返回值，则可以连续多次调用同一个方法从而使代码更加简洁，但可能造成实际意义的模糊。

### 方法详解

方法是类或对象的行为特征的抽象，是类和对象最重要的组成部分。

#### 方法 vs 函数

* 方法是由传统的函数发展而来的，定义语法和功能都很相似。
* 结构化编程语言中，系统是由函数组成，面向对象编程语言中系统是由类组成。因此，Java 里方法不能单独存在，必须属于类或对象。

#### 方法的所属性

* 方法不能独立定义，只能在类体里定义。
* 从逻辑上看，方法要么属于该类本身，要么属于该类的一个对象。
* 不能独立执行方法，执行方法必须使用类或对象作为调用者。
* 使用 static 修饰的方法属于类本身，类和对象都可以为调用者，但任何对象调用这个方法都会得到相同的执行结果。
* 没有 static 修饰的方法属于该类的对象，只能通过对象调用，不同对象调用可能得到不同结果。

#### 方法的参数传递机制

如果声明方法时包含了形参声明， 则调用方法时必须给这些行参指定参数值，调用方法时实际传给行参的参数值也被称为实参。

Java 里方法的参数传递方式只有一个：值传递。所谓值传递就是将实际参数值的副本（复制品）传入方法内，参数本身不会受到任何影响。

传引用变量时，传的是栈内存中引用变量（指针）的复制品，而两引用变量指向统一堆内存。

#### 参数个数可变的方法

定义方法时，在最后一个行参的类型后面加上三点(…)，则表明该行参可以接受多个参数值。多参数值传入后，方法内部当作数组处理。

```java
public void test1(int a, String... b);
public void test2(int a, String[] b);
// 两方法内部实现可以完全相同，但调用时存在差别。
test1(1, "a", "b");
test2(2, new String[]{"a", "b"});
// 对比两种调用代码，可见第一种形式更简洁。
```

#### 递归方法

一个方法体内调用它的自身，被称为方法递归。方法递归包含了一种隐式的循环，他会重复执行某段代码。

递归一定要向已知方向进行。

#### 方法重载

Java 允许同一个类里面定义多个同名方法，只要行参列表不同就行。称之为方法重载。

Java 中确定一个方法需要三个要素：

1. 调用者，也就是方法的所属者。
2. 方法名，方法的标识。
3. 行参列表，调用方法时，系统将会根据传入的实参列表匹配。

方法重载要求（两同一不同）：

* 同一类中方法名相同
* 行参列表不同

如果由于可变参数导致方法重载，系统会匹配只传一个参数的方法（类似于最小匹配原则）。一般情况下不推荐重载行参个数可变的方法。

### 成员变量和局部变量

#### 定义

成员变量指的是类里定义的变量，局部变量指的是方法里定义的变量

* 成员变量
  * 类变量（以 static 修饰），与类共存，类准备阶段起到类销毁止有效，无须显示初始化。
  * 实例变量（不以 static 修饰），与实例共存，实例被创建起到完全销毁止有效，无须显示初始化。
* 局部变量
  * 行参（方法签名中定义的变量），整个方法有效，无须显示初始化。
  * 方法局部变量（方法内定义的变量），从定义开始到方法结束截止有效，必须显示初始化。
  * 代码块局部变量（代码块内定义的变量），定义开始到代码块结束截止有效，必须显示初始化。

Java 允许局部变量和成员变量同名，局部变量会覆盖成员变量，成员变量可使用 this（对于实例变量）或类名（对于类变量）作为调用者来限定访问成员变量。

#### 成员变量的初始化和内存中的运行机制

当系统加载类或创建该类的实例时，系统自动为成员变量分配内存空间，并在分配内存空间后，自动为成员变量指定初始值。

#### 局部变量的初始化和内存中的运行机制

定义局部变量后，系统并没有为这个变量分配内存空间，直到程序为这个变量赋初始值，系统才会为局部变量分配内存，并将初始值保存到这块内存中。

局部变量总是保存在其所在方法的栈内存中。

#### 变量的使用规则

遵循物理规则的基础上，使用尽可能“小”的变量。

变量范围扩大的害处：

* 增大变量生存时间，导致更大的内存开销。
* 扩大变量作用域，不利于提高程序的内聚性。

应该考虑成员变量的情形：

* 用于描述某个类或某个对象的固有信息。
* 某个类中需要以一个变量保存该类或者实例运行时的状态信息。
* 某个信息需要在某个类的多个方法之间进行共享。

### 隐藏和封装

#### 理解封装

封装（Encapsulation）是面向对象的三大特性之一，指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。

对类或对象实现良好的封装可实现一下目的：

* 隐藏类的实现细节。
* 让使用者只能通过事先预定的方法来访问数据，限制对成员变量的不合理访问。
* 可进行数据检查，有利于保证对象信息的完整性。
* 便于修改，提高代码的可维护性。

为了实现良好的封装，需要从两方面考虑：

* 将对象的成员变量和实现细节隐藏起来，不允许外部直接访问。
* 把方法暴露出来，让方法来控制这些成员变量，进行安全的访问和操作。

#### 使用访问控制符

Java 提供了三个访问控制符：private、protected、public，也可以不加访问控制符，所以提供了4个访问控制级别，从小到大分别是 private、default、protected、public。

* private（当前类访问权限）：适合用于修饰成员变量，可以把成员变量隐藏在该类内部。

* dafault（包访问权限）：可被相同包下的其他类访问。

* protected（子类访问权限）：即可被同一包中其他类访问，也可以被不同包中的子类访问，使用 protected 通常是希望子类重写这个方法。

* public（公共访问权限）

  访问控制级别表：

  |            | private | default | protected | public |
  | :--------: | :-----: | :-----: | :-------: | :----: |
  | 同一个类中 |    √    |    √    |     √     |   √    |
  | 同一个包中 |         |    √    |     √     |   √    |
  |   子类中   |         |         |     √     |   √    |
  | 全局范围内 |         |         |           |   √    |

如果 Java 源文件中没有 public 修饰的类，则这个 Java 源文件的文件名可以是一切合法的文件名，如果 Java 源文件中定义了一个 public 修饰的类，则这个源文件的文件名必须与 public 修饰的类的类名相同。

如果一个 Java 类的每个实例变量都被使用 private 修饰，并为每个实例变量都提供了 public 修饰符的 setter 和 getter 方法，那么这个类就是一个符合 JavaBean 规范的类（封装良好的类）。

访问控制符使用的基本规则：

* 类里的绝大部分成员变量都应该使用 private 修饰，只有一些 static 修饰的、类似全局变量的成员变量才可以考虑使用 public 修饰。
* 如果某个类主要用做其他类的父类，该类里包含的大部分方法可能仅希望被其子类重写，而不被外界直接调用，则应该使用 protected 修饰这些方法。
* 希望暴露出来给其他类自由调用的方法应该使用 public 修饰符。

#### package、import、import static

##### package

Java 引入包（package）机制，提供了类的多层命名空间，用于解决类的命名冲突、类文件管理等问题。

Java 允许将一组功能相关的类放在同一个 package 下，从而组成逻辑上的类库单元。如果希望把一个类放在指定的包结构下，应该在 Java 源程序的第一个非注释行放置如下格式的代码：

```java
package packageName;
```

一旦在 Java 源文件中使用了这个 package 语句，就意味着该源文件里定义的所有类都属于这个包。位于包中的每个类的完整类名都应该是包名和类名的组合。

Java 规定：位于包中的类，在文件系统中也必须有与包名层次相同的目录结构。

JVM 在装载带有包名的类时，会先搜索 CLASSPATH 下的子路径，然后在这些目录中按与包层次对应的目录结构去查找 class 文件。同一个包中的类不必位于相同的目录下，只要让 CLASSPATH 包含这些个路径即可。虽然如此，也应该把 Java 源文件放在一个目录下。

Oracle 建议使用公司 Internet 域名倒些来作为包名。

父包和子包之间确实表示了某种内在的逻辑关系，但用法上则不存在任何关系，如果父包的类需要使用子包的类，则必须使用子包的全名。

##### import

如果需要使用不同包中的其他类时，总是需要使用该类的全名，这是一件很繁琐的事情，为了简化编程，Java 引入 import 关键字，import 可以向某个 Java 文件中导入指定包层次下某个类或全部类，import 语句应该出现在 package 语句（如果有）之后、类定义之前，import 用法如下：

```java
// 导入单个类
import package.subpackage...ClassName;
// 导入指定包下的全部类
import package.subpackage...*;
// * 只能代表类，不能代表包
```

Java 默认为所有源文件导入 java.lang 包下的所有类。

JDK 1.5 以后增加了静态导入的语法，用于导入指定类的某个（或全部）静态成员变量、方法，语法如下：

```java
// 导入单个静态成员变量、方法
import static package.subpackage...ClassName.fieldName|methodName;
// 导入指定包下的全部静态成员变量、方法
import static package.subpackage...ClassName.*;
```

使用 import 可以省略写包名，而使用 import static 则可以连类名都省略。

现在可以总结出 Java 源文件的大体结构如下：

```java
// 0或1个，必须放在文件开始
package 语句
// 0或多个，必须放在类定义之前
import | import static 语句
// 0或1个publilc类、接口或枚举定义
public classDefinition | interfaceDefinition | enumDefinition
// 0或多个普通类、接口或枚举定义
classDefinition | interfaceDefinition | enumDefinition
```

#### Java 的常用包

* java.lang：Java 语言的核心类，如 String、Math、System、Thread 等，系统自动导入，无需 import。
* java.util：大量工具类/接口和集合框架类/接口，例如 Arrays、List、Set 等。
* java.net：网络编程相关类/接口。
* java.io：输入输入相关类/接口。
* java.text：格式化相关类。
* java.sql：JDBC 数据库编程相关类/接口。
* java.awt：抽象窗口工具集（Abstract Window Toolkits）相关类/接口，主要用于构建图形用户界面（GUI）程序。
* java.swing：Swing 图形用户界面编程的相关类/接口，可用来构建平台无关的 GUI 程序。

### 深入构造器

构造器是一个特殊的方法，用于创建实例时执行初始化。是创建对象的重要途径（即便使用工厂模式、反射等方式创建对象，其实质依然是依赖于构造器），因此 Java 类必须至少包含一个构造器。

构造器名必须与类名相同包。

如果程序员没有为 Java 类提供任何构造器，则系统会为这个类提供一个无参数的、执行体为空的构造器。一旦程序员提供了自定义的构造器，系统就不再提供默认的构造器了。

如果希望有多个初始化过程，可以重载多个构造器。因为构造器主要用于被其他方法调用以返回该类的实例，所以一般使用 public 修饰符。

使用 this 调用另一个重载的构造器只能在构造器中使用，而且必须作为构造器执行体的第一条语句。

### 类的继承

继承是面向对象的三大特征之一，也是实现软件复用的重要手段。Java 的继承具有单继承的特点，每个子类只有一个直接父类。

#### 继承的特点

Java 的继承通过 extends 关键字来实现，实现继承的类被称为子类，被继承的类被称为父类（基类、超类）。

父类和子类是中一般和特殊的关系，子类是种特殊的父类，父类的范围总比子类要大。

Java 子类继承父类的语法如下：

```java
修饰符 class SubClass extends SupperClass
{
	// 类定义部分
}
```

extends 是扩展的意思，子类是父类的扩展。

Java 的子类不能获得父类的构造器。

从子类角度来看，子类扩展（extends）了父类；从父类的角度来看，父类派生（derive）出了子类。也就是说扩展和派生描述的是同一个动作，只是观察角度不同。

#### 重写父类的方法

子类包含与父类同名方法的现象被称为方法重写（Override），也被称为方法覆盖。

方法的重写要遵循“两同两小一大”规则：

* 两同：方法名称相同、行参列表相同。
* 两小：子类方法的返回值类型应小于等于父类方法，子类方法声明抛出的异常类应小于等于父类方法的。
* 一大：子类方法的访问权限应大于等于父类方法的。
* 覆盖和被覆盖的方法要么都是类方法，要么都是实例方法。

当子类覆盖了父类方法后，子类的对象将无法访问父类中被覆盖的方法，但可以在子类方法中调用父类中被覆盖的方法。使用 super（被覆盖的是实例方法），使用父类名称（被覆盖的是类方法）作为调用者来调用父类中被覆盖的方法。

如果父类方法有 private 访问权限，则该方法对子类是隐藏的，子类定义同名方法不属于重写，只是定义了个新方法。

##### 重载（overload）vs 重写（override）

* 没啥对比的意义。
* 重载发生在一个类的多个同名方法之间，多个不同方法。当然子类和父类方法直接也可能重载。
* 重写发生在子类和父类的同名方法之间，覆盖方法。

#### super 限定

supper 是 Java 提供的一个关键字，用于限定该对象从父类继承得到的变量或方法。正如 this 一样，supper 也不能出现在 static 修饰的方法中。static 修饰的方法是属于类的，该方法的调用者可能是一个类，而不是对象，因而 super 限定也就失去了意义。

如果在构造器中使用 super，则 super 用于限定该构造器初始化的是该对象从父类继承得到的实例变量，而不是该类自己定义的。

如果在某个方法中访问名为 a 的成员变量，但没有显示指定调用者，则系统查找 a 的顺序为：

1. 查找该方法中是否有名为 a 的局部变量。
2. 查找当前类中是否包含名为 a 的成员变量。
3. 依次上溯当前类的所有父类，直到 java.land.Object 类，查找名为 a 的成员变量，如未找到则系统出现编译错误。

#### 调用父类的构造器

子类不会获得父类的构造器，但子类构造器里可以调用父类构造器的初始化代码，类似于前面介绍的一个构造器调用另一个重载的构造器。在一个构造器中调用另一个重载的构造器使用 this，子类构造器中调用父类构造器使用 super。与 this 调用一样，super 调用也必须出现在子类构造器执行体的第一行。

当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行，递归，创建任何 Java 对象，最先执行的总是 Java.land.Object 类的构造器。

### 多态

Java 引用变量有两个类型：

* 编译时类型，由声明该变量时使用的类型决定。
* 运行时类型，由实际赋给该变量的对象决定。

如果编译时类型和运行时类型不一致，就可能出现所谓的多态（Polymorphism）。

#### 多态性

因为子类其实是一种特殊的父类，因此 Java 允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型（upcasting），向上转型由系统自动完成。当运行时调用该引用变量的方法时，其方法行为总是变现出子类方法的行为特征，这就可能出现：相同类型的变量、调用同一方法时呈现出多种不同的行为特征，这就是多态。

与方法不同，对象的实例变量不具备多态性。

引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法，因此，编写 Java 代码时只能调用声明该变量所用类里包含的方法。

通过引用变量来访问其包含的实例变量时，系统总是试图访问它编译时类型所定义的成员变量，而不是它运行时类型所定义的成员变量。

#### 引用变量的强制类型转换

强制类型转换需要借助于类型转换运算符，小括号，用法：`(type)variable`，这种用法可以将 variable 变量转换成一个 type 类型的变量。当进行强制类型转换时应注意：

* 基本类型之间的转换只能在数值类型之间进行。
* 引用类型之间的转换只能在具有继承关系的两个类型之间进行。
* 在进行强制类型转换之前，应先用 instanceof 运算符判断是否可以转换成功，从而避免出现 ClassCastException 异常。

#### instanceof 运算符

instanceof 运算符的前一个操作数通常是一个引用变量，后面一个操作数通常是一个类（也可以是接口，可以把接口理解成一种特殊的类），它用于判断前面的对象是否是后面的类，或者其子类、实现类的实例。

使用时应注意：运算符前面的操作数的编译时类型要么与后面的类型相同，要么与后面的类具有父子继承关系，否则会引起编译错误。

### 继承与组合

继承是实现类复用的重要手段，但继承带来了一个最大坏处：破坏封装。相比之下，组合也是实现类复用的重要方式，而采用组合方式来实现类复用则能提供更好的封装性。

#### 使用继承的注意点

设计父类通常应遵循如下规则：

* 尽量隐藏父类的内部数据。
* 不要让子类可以随意访问、修改父类的方法。不希望子类访问应使用 private，不希望子类重写可以使用 final 修饰符，希望子类重写，不希望其他类自由访问可使用 protected。
* 尽量不要在父类构造器中调用将要被子类重写的方法。

何时需要从父类派生子类：

* 保证子类是一种特殊的父类。
* 子类需要额外增加属性，而不是仅仅改变属性值。
* 子类需要增加自己独有的行为方式（包括增加新的方法或重写父类的方法）。

#### 利用组合实现复用

通过把该类当成另一个类额组合部分来实现复用，从而允许新类直接复用该类的 public 方法。

把旧类对象作为新类的成员变量组合进来，用以实现新类的功能。

继承设计与组合设计的系统开销不会有本质的差别。

选择继承还是选择组合实现复用最好遵循物理逻辑。

### 初始化块

#### 使用初始化块

初始化块是 Java 类里可出现的第4种成员（前面依次有成员变量、方法和构造器），一个类里可以有多个初始化块，相同类型的初始化块之间有顺序：前面定义的先执行，后面定义的后执行。初始化块语法格式如下：

```java
[修饰符] {
	// 初始化块的可执行性代码
	...
}
```

初始化块的修饰符只能是 static，使用 static 修饰的初始化块被称为静态初始化块。初始化块里的代码可以包含任何可执行性语句，包括定义局部变量、调用其他对象的方法，以及使用分支、循环语句等。

当创建 Java 对象时，系统总是先调用该类里定义的初始化块。

初始化块虽然也是 Java 类的一种成员，但它没有名字，也没有标识，因此无法通过类、对象来调用。初始化块只有在创建 Java 对象时隐式执行，而且在执行构造器之前执行。

虽然 Java 允许一个类里定义两个初始化块，但这没有任何意义，完全可以将多个初始化块合并，从而让程序更加简洁，可读性更强。

当 Java 创建一个对象时，系统先为该对象的所有实例变量分配内存（前提是该类已经被加载过了），接着开始对这些实例变量执行初始化，其初始化顺序是：先执行初始化块或声明实例变量时指定的初始值（这两个地方指定初始值的执行允许与它们在源代码中的排列顺序相同），再执行构造器里指定的初始值。

#### 初始化块和构造器

初始化块是一段固定的代码，它不能接收任何参数。因此初始化块对同一个类的所有对象所进行的初始化处理完全相同。基于这个原因，不难发现初始化块的基本用法，如果有一段初始化处理代码对所有对象完全相同，且无需接收任何参数，就可以把这段初始化处理代码提取到初始化块中。

实际上初始化块是一个假象，使用 javac 命令编译 Java 类后，该 Java 类中的初始化块会消失——初始化块中的代码会被“还原”到每个构造器中，且位于构造器所有代码的前面。

与构造器类似，创建一个 Java 对象时，不仅会执行该类的普通初始化块和构造器，而且会一直上溯到 Java.lang.Object 类，依次向下执行初始化块、构造器。

#### 静态初始化块

如果定义初始化块时使用了 static 修饰符，则这个初始化块就变成了静态初始化块，也被称为类初始化块（普通初始化块负责对对象执行初始化，类初始化块则负责对类进行初始化）。静态初始化块是类相关的，系统将在类初始化阶段执行静态初始化块，因此静态初始化块总比普通初始化块先执行。上溯到 java.lang.Object，自上向下，所有静态初始化块执行完后，才开始自上向下执行普通初始化块和构造器。

静态初始化块也属于类的静态变量，不能访问非静态成员。

当 JVM 第一次主动使用某类时，系统会在类准备阶段为该类的所有静态成员变量分配内存；在初始化阶段则负责初始化这些静态成员变量，初始化静态成员变量就是执行类初始化代码或者声明类成员变量时指定的初始值，它们的执行顺序与源代码中的排列顺序相同。



## 面向对象（下）

### Java8 增强的包装类

Java 是面向对象的编程语言，但它也包含了8种不支持面向对象编程机制的基本类型，为了解决8种基本类型的变量不能当成 Object 类型变量使用的问题，Java 提供了包装类（Wrapper Class）的概念，为8种基本类型分别定义了相应的引用类型，并称之为基本数据类型的包装类。

基本数据类型和包装类型的对应关系如下：

| 基本数据类型 |  包装类   |
| :----------: | :-------: |
|     byte     |   Byte    |
|    short     |   Short   |
|     int      |  Integer  |
|     long     |   Long    |
|     char     | Character |
|    float     |   Float   |
|    double    |  Double   |
|   boolean    |  Boolean  |

JDK1.5 提供了自动装箱（Autoboxing）和自动拆箱（AutoUnboxing）功能，

* 自动装箱：可以把一个基本类型直接赋给对应的包装类变量，或者赋给 Object 变量（Object 是所有类的父类，子类对象可以直接赋给父类变量）。
* 自动拆箱：允许直接把包装类对象赋给一个对应的基本类型变量。

包装类还可以实现基本类型变量和字符串之间的转换，把字符串转换为基本类型有两种方式：

* 利用包装类提供的 parseXxx(String s) 静态方法（处 Character 外所有包装类都提供了该方法）。
* 利用包装类提供的 valueOf(String s) 静态方法。

String 类也提供了多个重载的 valueOf() 方法，用于将基本类型转换成字符串。

```mermaid
graph LR
	base("基本变量类型") --"通过String.valueOf(primitive)转换"-->String("String对象")
	String --"通过WrapperClass.parseXxx()方法<br/>或valueOf()方法"-->base
```

如果希望把基本类型变量转换成字符串，还有一种更简单的方法：将基本类型变量和空字符串("")进行连接运算，系统会自动把基本类型变量抓换成字符串。

Q：同样两个 int 类型的数值自动装箱成 Integer 实例后，如果两个2装箱后就相等，但两个128就不相等，原因如下：

A：查看 Integer 源代码发现，系统把一个 -128~127 之间的整数自动装箱成 Integer 实例，并放入一个名为 cache 的数组中缓存起来。如果以后把一个 -128~127 之间的整数自动装箱成一个 Integer 实例时，实际上是直接指向对应的数组元素，因此 -128~127 之间的同一个整数自动装箱成 Integer 实例时，永远都是引用 cache 数组的同一个数组元素，所以它们全部相等；每次把一个不在 -128~127 范围内的整数自动装箱成 Integer 实例时，系统总是重新创建一个 Integer 实例，所以它们不相等。

Q：Java 为什么要对这些数据进行缓存？

A：Java 把一些创建成本大、需要频繁使用的对象缓存起来，从而提高程序的运行性能。

Java7 增强了包装类的功能，所有包装类都提供了一个静态的 conpare(xxx val1, xxx val2)，同来比较两个基本类型“值”的大小。Java7 还为 Character 包装类增加了大量的工具方法来对一个字符串进行判断。

Java8 再次增强包装类，为整形包装类增加了支持无符号的运算方法。

### 处理对象

#### 打印对象和 toString 方法

toString() 方法是 object 类里的一个实例方法，是个非常特殊的方法，用于“自我描述”。如果用户需要自定义类能实现“自我描述”的功能，就必须重写 Object 类的 toString() 方法。

#### == 和 eqluals 方法

均用类测试两个变量是否相等。

* ==
  * 对于基础类型变量，用来比较两变量值是否相等。
  * 对于引用变量，用来比较它们是否指向同一对象（值相等不一定==）。
* equals
  * Object 提供的一个实例方法，与 == 作用完全相同。
  * 如果希望采用自定义标准，可以重写该方法。
  * String、Integer 等类已经重写了 Object 的 equals() 方法，通常是判断两变量值是否相等。
  * 通常而言，正确地重写 equals() 方法应满足系列条件：
    * 自反性：对任意 x，x.equals(x) 一定返回 true。
    * 对称性：对任意 x 和 y，如果 y.equals(x) 返回 true，则 x.equals(y) 也返回 true。
    * 传递性：对任意 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 一定也返回 true。
    * 一致性：对任意 x、y，如果对象中用于等价比较的信息没有改变，那么无论调用 x.equals(y) 多少次，返回的结果应保持一致。
    * 对任何不是 null 的 x，x.equals(null) 一定返回 false。

### 类成员

#### 理解类成员

Java 类里只能包括成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员，其中 static 可以修饰处构造器外的4种成员，以 static 修饰的成员就是类成员。类成员属于整个类，不属于单个对象。

当系统第一次准备使用该类时，系统会为该类变量分配内存空间，类变量开始生效，直到该类被卸载，该类的类变量所占的内存才被系统的垃圾回收机制回收。类变量生存范围几乎等同于该类的生存范围。

类变量既可以通过类来访问，也可以通过对象来访问，但本质上都是通过类访问。           

类方法也是类成员的一种，属于类，即可通过类访问，也可通过对象访问，本质上都是通过类访问的。即使某个实例为 null，它也可以访问它所属类的类成员。

如果一个 null 对象访问实例成员（包括实例变量和实例方法），将会引发 NullPointerException 异常，因为 null 表示该实例根本不存在，那么它的实例变量和实例变量方法自然也不存在。

静态初始化块也是类成员的一种，用于执行类的初始化动作。一旦类初始化结束后，静态初始化块将永远不会获得执行机会。

对 static 关键字而言，有一条非常重要的规则：类成员不能访问实例成员。因为类成员是属于类的，类成员的作用域比实例成员的更大，完全可能出现类成员已经初始化完，实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误。

#### 单例（Singleton）类

大部分时候都把类的构造器定义为 public 访问权限，允许任何类创建该类的对象。但某些时候，允许其他类自由创建该类的对象没有意义，还可能造成系统性能下降，例如系统可能只有一个窗口管理器、一个数据库引擎访问点等。

如果一个类始终只能创建一个实例，则这个类被称为单例类。

为了避免其他类自由创建该类的实例，应该把该类的构造器使用 private 修饰。根据良好封装的原则：一旦把该类的构造器隐藏起来，就需要提供一个 public 方法作为该类的访问点，用于创建该类的对象，且该方法必须用 static 修饰符（因为调用该方法前还不存在对象，因此只能是类方法）。

此外，该类必须缓存已创建的对象，否则无法知道是否曾经创建过对象，也就无法保证只创建一个对象。为此需要一个 static 修饰的成员变量来保存曾经创建的对象。

### final 修饰符

final 关键字可用于修饰类、变量和方法，用来表示不可改变。

final 修饰变量时，表示该变量一旦获得了初始值就不可被改变。

#### final 成员变量

final 修饰的成员变量必须由程序员显式地指定初始值，指定初始值的地方如下：

* 类变量：静态初始化块或声明该类变量时指定初始值。
* 实例变量：非静态初始化、声明该实例变量或构造器中指定初始值。

尽量避免在 final 变量显示初始化之前访问它。

#### final 局部变量

使用 final 修饰局部变量时，既可以在定义时指定默认值，也可以在后面代码中指定默认值，但只能一次。

final 修饰行参，因为行参在调用该方法时，由系统根据传入的参数来完成初始化，因此使用 final 修饰的行参不能在方法执行体中被赋值。

#### final 修饰基本类型变量和引用类型变量的区别

* 基本类型：不能改变。
* 引用类型：引用的地址不能改变，引用的对象可以改变。

#### 可执行“宏替换”的 final 变量

对于一个 final 变量来说（不管是类变量、实例变量还是局部变量），只要变量满足三个条件，这个 final 变量就不再是一个变量，而是相当于一个直接量。

* 使用 final 修饰符修饰。
* 在定义该 final 变量时指定了初始值。
* 该初始值在编译时就被确定下来。

这个 final 变量本质上就是一个“宏变量”，编译器会把程序中所有用到该变量的地方直接替换成该变量的值。

除符合上述条件的 final 变量外，如果变量被赋的表达式只是基本的算术表达式或字符串连接运算，没有访问普通变量、调用方法，Java 编译器同样会将这种 final 变量当成“宏变量”理解。

#### final 方法

final 修饰的方法不可被重写。例如 Object 类里的 getClass() 就是 final 方法。

#### final 类

final 修饰的类不可以有子类。例如 java.lang.Math 类就是一个 final 类，它不可以有子类。

#### 不可变类

不可变（immutable）类的意思是创建该类的实例后，该实例的实例变量是不可变的。Java 提供的8个包装类和 java.lang.String 类都是不可变，当创建它们的实例后，其实例的实例变量不可改变。

如果需要创建自定义的不可变类，可遵守如下规则：

* 使用 private 和 final 修饰符来修饰该类的成员变量。
* 提供代参数的构造器，用于根据传入参数来初始化类里的成员变量。
* 仅为该类的成员变量提供 getter 方法，不提供 setter 方法。
* 如果必要，重写 Object 类的 hashCode() 和 equals() 方法。

如果需要设计一个不可变类，尤其要注意其引用类型的成员变量，如果引用类型的成员变量的类是可变的，就必须采取必要的措施来保护该成员变量所引用的对象不会被修改，这样才能创建真正的不可变类。

#### 缓存实例的不可变类

不可变类的实例状态不可改变，可以很方便地被多个对象所共享，如果程序经常需要使用相同的不可变类实例，可以考虑将其缓存。

### 抽象类

#### 抽象类和抽象方法

抽象方法和抽象类必须使用 abstract 修饰符来定义，有抽象方法的类只能被定义为抽象类，抽象类里可以没有抽象方法。

抽象方法和抽象类的规则如下：

* 必须使用 abstract 修饰符修饰，抽象方法不能有方法体。
* 抽象类不能被实例化，无法使用 new 关键字来调用抽象类的构造器。
* 抽象类可以包含成员变量、方法（普通方法和抽象方法）、构造器、初始化块、内部类（接口、枚举）5种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。
* 含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含的抽象方法三种情况）能被定义成抽象类。 

归纳起来，抽象类：

* 可以定义抽象方法。
* 不能创建实例。

抽象方法和空方法不是同一个概念。

final 和 abstrict 不能同时使用。

static 和 abstric 并不是绝对互斥的，它们虽然不能同时修饰某个方法，但可以同时修饰内部类。

private 和 abstric 不能同时修饰方法。

#### 抽象类的作用

从语义的角度来看，抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。抽象类作为其子类的模版，避免了子类设计的随意性。

抽象类体现的就是一种模版模式的设计，抽象类作为多个子类的通用模版，子类在抽象类的基础上进行扩展、改造，但子类会大致保留抽象类的行为方式。

模版模式在面向对象的软件中很常用，下面是其一些规则：

* 抽象父类可以只定义需要使用的一些方法，把不能实现的部分抽象成抽象方法，留给其子类去实现。
* 父类中可能包含需要调用其他系列方法的方法，这些被调方法既可以由父类实现，也可以由其子类实现。父类里提供的方法只是定义了一个通用算法，其实现也许并不完全由自身实现，而是必须依赖其子类的辅助。