#!/usr/bin/env python3
# ! -*- coding:utf-8 -*-

from doFunc import doFunc

"""
本章介绍一些技巧使项目代码结构变得整洁、有逻辑感。项目刚开始时不会觉得有用，一段时间后就能体现出价值
模块和包是任何大型项目的核心，就连Python安装程序本身也是一个包
"""


def func1():
    """
    把模块按层次结构组成包

    定义一个具有层次结构的模块就像在文件系统上创建目录结构一样简单。__init__.py文件的目的就是包含可选的初始化代码，当遇到软件包中不同层次的模块时会触发运行
    如果写下import graphics语句，文件graphics/__init__.py会被导入并形成graphics命名空间中的内容
    对于import graphics.formats.jpg这样的导入语句，文件graphics/__init__.py和graphics/formats/__init__.py都会在最终导入文件graphics/formats/jpg.py之前优先得到导入

    大部分情况下，把__init__.py文件留空也是可以的。但是，在某些特定的情况下__init__.py文件中是需要包含代码的，例如，可以用__init__.py文件来自动加载子模块
    # graphics/formats/__init__.py
    from . import jpg
    from . import png
    有了这样一个文件，用户只需要使用一条单独的import graphics.formats语句就可以导入jpg和png模块了，不需要再去分别导入
    个人感觉这样自动导入，使用者或者代码阅读者会比较晕，尽量少用

    Python3.3开始就算不存在__init__.py文件似乎也可以执行包的导入操作。如果不定义__init__.py，那么实际上创建一个称之为"命名空间包(namespace package)的东西"
    """


def func2():
    """
    对所有符号的导入进行精确控制

    在模块中定义一个__all__变量，可用来显式列出可导出的符号名

    # some_module.py
    def spam():
        pass
    def grok():
        pass
    blah = 42
    __all__ = ['spam', 'grok']

    尽管强烈反对使用from module import * 这样的导入语句，但是在定义了大量符号的模块中还是能常看到这种用法。如果对此无动于衷的话，这种形式的导入会把所有不以下划线开头的符号名全部导出。
    如果定义了__all__，那么显式列出符号名才会被导出；如果__all__中包含为定义的名称，那么在执行import语句时会产生一个AttributeError异常

    个人看法：如果模块非常关键，那么最好定义__all__来帮助那些使用import * 的人。
    真正的强者，愿意以弱者的自由为边界
    """


def func3():
    """
    用相对名称来导入包中的子模块

    在包的内部，要在其中一个子模块中导入同一个包中其他的子模块，既可以通过给出完整的绝对名称，也可以通过相对名称完成导入
    使用绝对名称的缺点在于这么做会将最顶层的包名称硬编码到源代码中，这使得代码更加脆弱，如果想重新组织目录结构会比较困难

    import语句中的 . 和 .. 语法看起来比较有趣，把它们想象成指定目录名即可。意味着在当前目录中查找，而 ..B 表示在 ../B 目录中查找。这种语法只能在 from xx import yy 这样的导入语句中使用

    尽管看起来似乎可以利用相对导入来访问整个文件系统，但实际上是不允许跳出定义包的那个目录的。也就是说，利用句点的组合形式进入一个不是Python包的目录会使得导入出现错误

    相对导入只有在特定情况下才起作用，即，模块必须位于一个合适的包中。
    注意，位于脚本顶层目录的模块不能使用相对导入，
    此外，如果包的某个部分是以脚本的形式执行的，也不能使用相对导入，可使用 -m 选项来执行，例如 python -m pip install ...

    个人看法：能用相对用相对，用不了再考虑绝对
    """


def func4():
    """
    将模块分解成多个文件

    个人看法：将一个模块分解成多个文件是十分舒爽的事，但也要明白过犹不及

    是否进行模块分解主要取决于一个设计上的问题，即，我们希望用户使用大量的小型模块，还是希望他们只使用一个单独的模块
    通过将模块转换为包的方式将模块分解成多个单独文件

    # 单文件模块
    # my_module.py
    class A:
        def spam(self):
            print('A.spam')

    class B(A):
        def bar(self):
            print('B.bar')

    # 拆分为两个文件
    my_module/
        __init__./py
        a.py
        b.py

    # a.py
    class A:
        def spam(self):
            print('A.spam')

    # b.py
    from .a import A

    class B(A):
        def bar(self):
            print('B.bar')

    # __init__.py

    from .a import A
    from .b import B

    在逻辑上把多个文件拼接成一个单独的命名空间的技术，关键之处在于创建一个包目录，并通过__init__.py文件将各个部分粘合在一起
    当分解模块时，需要对跨文件名的引用多加小心

    可以对本节提到的技术进行扩展，引入"惰性"导入的概念，只希望在实际需要的时候才加载那些组件。为了实现这个目的，可对__init__.py文件做些修改
    # __init__.py

    def A():
        from .a import A
        return A()

    def B():
        from .b import B
        return B()

    惰性加载的主要缺点在于会破坏继承和类型检查机制
    """


def func5():
    """
    让各个目录下的代码在统一的命名空间下导入

    我们想定义一个顶层的Python包，把它作为命名空间来管理大量单独维护的子模块。这个问题常常会在大型的应用程序框架中出现，框架开发人员希望鼓励用户发布自己的插件或者附加包
    要使各个单独的目录统一在一个公共的命名空间下，可以把代码像普通的Python包那样组织。但对于打算合并在一起的组件，这些目录中的__init__.py文件则需要忽略

    foo-package/
        spam/
            blah.py

    bar-package/
        spam/
            grok.py

    在这两个目录中，spam用来作为公共的命名空间。注意这两个目录中都没有出现__init__.py文件
    如果将 foo-package 和 bar-package 都添加到 Python 的模块查询路径中，然后尝试做一些导入操作
    import sys
    sys.path.extend(['foo-package', 'bar-package'])
    import spam.blah
    import spam.grok
    这两个不同的包目录魔法般地合并在了一起，我们可以随意导入spam.blah或者spam.grok

    这里的工作原理用到了一种称之为"命名空间包(namespace package)的特性。
    命名空间包是一种特殊的包，设计这种特性的意图就是用来合并不同目录下的代码，把它们放在统一的命名空间下管理。
    这样就允许把框架的某些部分分解成单独安装的包，也使制作第三方插件和针对框架的其他扩展的成本降低

    创建命名空间包的关键之处在于确保在统一命名空间的顶层目录中不包含__init__.py文件，当导入包的时候，这个缺失的__init__.py文件会导致发生一个有趣的事情
    解释器并不会因此而产生一个错误，相反，解释器开始创建一个列表，把所有恰好包含有这个包名的目录都囊括在内。
    此时就创建出一个特殊的命名空间包模块，且在__path__变量中会保存一份只读形式的目录列表

    命名空间包的一个重要特性就是任何人都可以用自己的代码来扩展命名空间中的内容

    想知道某个包是不是用来当作命名空间包的主要方式是检查它的__file__属性，如果缺少这个属性，就是命名空间包
    也可以从对包对象的字符串表示中看出来，如果是命名空间的话，其中会有"namespace"的字样
    """


if __name__ == '__main__':
    doFunc()
